[["index.html", "Functional Programming Welcome An evolving book", " Functional Programming Sara Altman, Bill Behrman, Hadley Wickham 2021-09-09 Welcome This book is a practical introduction to functional programming using the tidyverse. An evolving book This book is not intended to be static. Starting in April 2019, we use this book to teach functional programming in the Stanford Data Challenge Lab (DCL) course. The DCL functions as a testing ground for educational materials, as our students give us routine feedback on what they read and do in the course. We use this feedback to constantly improve our materials, including this book. The source for the book is also available on GitHub where we welcome suggestions for improvements. This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],["data-structures.html", "1 Introduction", " 1 Introduction When you work with data in R, your data will always be stored in some type of data structure. In this section, we’ll discuss the most common data structures: atomic vectors, lists, and tibbles. You’ll learn how to create and manipulate each type, as well as what distinguishes them from each other. "],["data-structure-basics.html", "2 Vectors, lists, and tibbles 2.1 Atomic vectors 2.2 Lists 2.3 Tibbles", " 2 Vectors, lists, and tibbles library(tidyverse) In R, vectors are the most common data structure. In this book, we’ll often represent vectors like this: Each orange cell represents one element of the vector. As you’ll see, different kinds of vectors can hold different kinds of elements. There are two kinds of vectors: atomic vectors and lists. Tibbles are a specific kind of list. In this chapter, we’ll cover these three data structures, explaining how they differ and showing you how to manipulate each one. 2.1 Atomic vectors Atomic vectors are the “atoms” of R—the simple building blocks upon which all else is built. There are four types of atomic vector that are important for data analysis: integer vectors (&lt;int&gt;) contain integers. double vectors (&lt;dbl&gt;) contain real numbers. character vectors (&lt;chr&gt;) contain strings made with \"\". logical vectors (&lt;lgl&gt;) contain TRUE or FALSE. Integer atomic vectors contain only integers, double atomic vectors contain only doubles, and so on. Together, integer and double vectors are known as numeric vectors. All vectors can also contain the missing value NA. In R, single numbers, logicals, and strings are just atomic vectors of length 1, so x &lt;- &quot;a&quot; creates a character vector. Likewise, y &lt;- 1.1 creates a double vector. To create atomic vectors with more than one element, use c() to combine values. logical &lt;- c(TRUE, FALSE, FALSE) double &lt;- c(1.5, 2.8, pi) character &lt;- c(&quot;this&quot;, &quot;is&quot;, &quot;a character&quot;, &quot;vector&quot;) To create an integer vector by hand, you’ll need to add L to the end of each number. integer &lt;- c(1L, 2L, 3L) Without the Ls, R will create a vector of doubles. 2.1.1 Properties Vectors (both atomic vectors and lists) all have two key properties: type and length. You can check the type of any vector with typeof(). typeof(c(1.5, 2.8, pi)) #&gt; [1] &quot;double&quot; typeof(c(1L, 3L, 4L)) #&gt; [1] &quot;integer&quot; Use length() to find a vector’s length. length(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; [1] 3 Vector can also have named elements. v_named &lt;- c(guava = 2, pineapple = 4, dragonfruit = 1) v_named #&gt; guava pineapple dragonfruit #&gt; 2 4 1 You can access a vector’s names with names(). names(v_named) #&gt; [1] &quot;guava&quot; &quot;pineapple&quot; &quot;dragonfruit&quot; 2.1.2 Subsetting v is an atomic vector of doubles. v &lt;- c(1, 2.7, 4, 5) You can subset v to create a new vector with selected elements, ignoring the others. The [ operator Here are four ways to subset v using the [ operator. Positive integers Subset with a vector of positive integers to extract elements by position. v[c(1, 2)] #&gt; [1] 1.0 2.7 Note that, in R, indices start at 1, not 0, so the above code extracts the first two elements of v. You can also use : to create a vector of adjacent integers. The following select the first three elements of v. v[1:3] #&gt; [1] 1.0 2.7 4.0 Negative integers Subset with a vector of negative integers to exclude elements. The following code removes the first and third elements of v. v[-c(1, 3)] #&gt; [1] 2.7 5.0 Names If a vector has names, you can subset with a character vector. v_named[c(&quot;guava&quot;, &quot;dragonfruit&quot;)] #&gt; guava dragonfruit #&gt; 2 1 Logical vectors If you supply a vector of TRUEs and FALSEs, [ will select the elements that correspond to the TRUEs. The following extracts just the first and third elements. v[c(TRUE, FALSE, TRUE, FALSE)] #&gt; [1] 1 4 You’ll rarely subset by typing out TRUEs and FALSEs. Instead, you’ll typically create a logical vector with a function or condition. For example, the following code selects just the elements of v greater than 2. v[v &gt; 2] #&gt; [1] 2.7 4.0 5.0 v &gt; 2 results in a logical vector the same length as v. v &gt; 2 #&gt; [1] FALSE TRUE TRUE TRUE [ then uses this logical vector to subset v, resulting in just the elements of v greater than 2. v_missing has NAs. v_missing &lt;- c(1.1, NA, 5, 6, NA) We can pass !is.na(v_missing) into [ to extract out just the non-NA elements. v_missing[!is.na(v_missing)] #&gt; [1] 1.1 5.0 6.0 The [[ operator You can extract single elements from a vector with the [[ operator. v[[2]] #&gt; [1] 2.7 You’ll get an error if you try to use [[ to select more than one element. v[[2:3]] #&gt; Error in v[[2:3]]: attempt to select more than one element in vectorIndex For named vectors, the [ operator creates a subset of the original vector with the specified elements. v_named[&quot;guava&quot;] #&gt; guava #&gt; 2 The [[ operator returns only the extracted element. v_named[[&quot;guava&quot;]] #&gt; [1] 2 As you’ll see in the Lists section that the distinction between [ and [[ becomes more important with lists and tibbles. 2.1.3 Applying functions Vectors are central to programming in R, and many R functions are designed to work with vectors. You already saw how to call typeof() to return the type of a vector. typeof(v) #&gt; [1] &quot;double&quot; sum() sums a vector’s elements. sum(v) #&gt; [1] 12.7 You can use sum() with both numeric (i.e., double and integer) vectors, as well as with logical vectors. logical &lt;- c(TRUE, TRUE, FALSE) sum(logical) #&gt; [1] 2 When applied to a logical vector, sum() returns the number of TRUEs. mean() works similarly. mean(v) #&gt; [1] 3.17 mean(logical) #&gt; [1] 0.667 The Base R Cheat Sheet has some other basic helpful functions, particularly under the Vector Functions and Math Functions sections. 2.1.4 Augmented vectors Augmented vectors are atomic vectors with additional metadata. There are four important augmented vectors: factors &lt;fct&gt;, which are used to represent categorical variables can take one of a fixed and known set of possible values (called the levels). ordered factors &lt;ord&gt;, which are like factors but where the levels have an intrinsic ordering (i.e. it’s reasonable to say that one level is “less than” or “greater than” another level). dates &lt;dt&gt;, record a date. date-times &lt;dttm&gt;, which are also known as POSIXct, record a date and a time. For now, you just need to recognize these when you encounter them. You’ll learn how to create each type of augmented vector later in the course. 2.2 Lists Unlike atomic vectors, which can only contain a single type, lists can contain any collection of R objects. 2.2.1 Basics The following reading will introduce you to lists: Recursive vectors (lists) 2.2.2 Flattening You can flatten a list into an atomic vector with unlist(). y &lt;- list(1, 2, 4) y #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 4 unlist(y) #&gt; [1] 1 2 4 unlist() returns an atomic vector even if the original list contains other lists or vectors. z &lt;- list(c(1, 2), c(3, 4)) z #&gt; [[1]] #&gt; [1] 1 2 #&gt; #&gt; [[2]] #&gt; [1] 3 4 unlist(z) #&gt; [1] 1 2 3 4 2.3 Tibbles Tibbles are actually lists. typeof(mpg) #&gt; [1] &quot;list&quot; Every tibble is a named list of vectors, each of the same length. These vectors form the tibble columns. Take the tibble mpg. mpg #&gt; # A tibble: 234 × 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… #&gt; 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… #&gt; 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… #&gt; 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… #&gt; 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… #&gt; 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… #&gt; # … with 228 more rows Each variable in mpg (manufacturer, model, displ, etc.) is a vector. manufacturer is a character vector, displ is a double vector, and so on. Each vector has length 234. 2.3.1 Creation There are two ways to create tibbles by hand. First, you can use tibble(). my_tibble &lt;- tibble( x = c(1, 9, 5), y = c(TRUE, FALSE, FALSE), z = c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) ) my_tibble #&gt; # A tibble: 3 × 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; #&gt; 1 1 TRUE apple #&gt; 2 9 FALSE pear #&gt; 3 5 FALSE banana tibble() takes individual vectors and turns them into a tibble. Second, you can use tribble(). my_tibble &lt;- tribble( ~x, ~y, ~z, 1, TRUE, &quot;apple&quot;, 9, FALSE, &quot;pear&quot;, 5, FALSE, &quot;banana&quot; ) my_tibble #&gt; # A tibble: 3 × 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; #&gt; 1 1 TRUE apple #&gt; 2 9 FALSE pear #&gt; 3 5 FALSE banana For small datasets, tribble() is likely to be less error prone, since the values for each row are next to each other. 2.3.2 Subsetting There are several ways to extract variables out of tibbles. Tibbles are lists, so [[ and $ work. my_tibble[[&quot;x&quot;]] #&gt; [1] 1 9 5 my_tibble$x #&gt; [1] 1 9 5 Use pull(), the dplyr equivalent, when you want to use a pipe. my_tibble %&gt;% pull(x) #&gt; [1] 1 9 5 Note that pull(), like [[ and $, returns just the vector of values for a given variable. [ also works with tibbles. my_tibble[&quot;x&quot;] #&gt; # A tibble: 3 × 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 1 #&gt; 2 9 #&gt; 3 5 For a pipe, use the dplyr function select(). my_tibble %&gt;% select(x) #&gt; # A tibble: 3 × 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 1 #&gt; 2 9 #&gt; 3 5 Whereas pull() returns a vector, select() returns a tibble. 2.3.3 Dimensions Printing a tibble tells you the column names and overall dimensions. mpg #&gt; # A tibble: 234 × 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… #&gt; 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… #&gt; 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… #&gt; 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… #&gt; 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… #&gt; 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… #&gt; # … with 228 more rows To access the dimensions directly, you have three options: dim(diamonds) #&gt; [1] 53940 10 nrow(diamonds) #&gt; [1] 53940 ncol(diamonds) #&gt; [1] 10 To get the variable names, use names(): names(diamonds) #&gt; [1] &quot;carat&quot; &quot;cut&quot; &quot;color&quot; &quot;clarity&quot; &quot;depth&quot; &quot;table&quot; &quot;price&quot; #&gt; [8] &quot;x&quot; &quot;y&quot; &quot;z&quot; "],["list-columns.html", "3 List columns 3.1 Creating 3.2 Unnesting 3.3 Manipulating", " 3 List columns # Libraries library(tidyverse) #&gt; ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── #&gt; ✓ ggplot2 3.3.5 ✓ purrr 0.3.4 #&gt; ✓ tibble 3.1.4 ✓ dplyr 1.0.7 #&gt; ✓ tidyr 1.1.3 ✓ stringr 1.4.0 #&gt; ✓ readr 2.0.1 ✓ forcats 0.5.1 #&gt; ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() library(dcldata) Recall that tibbles are lists of vectors. Usually, these vectors are atomic vectors, so the elements in the columns are single values, like “a” or 1. Tibbles can also have columns that are lists. These columns are (appropriately) called list columns. List columns are more flexible than normal, atomic vector columns. Lists can contain anything, so a list column can be made up of atomic vectors, other lists, tibbles, etc. As you’ll see, this can be a useful way to store data. In this chapter, you’ll learn how to create list columns, how to turn list columns back into normal columns, and how to manipulate list columns. 3.1 Creating Typically, you’ll create list columns by manipulating an existing tibble. There are three primary ways to create list columns: nest() summarize() and list() mutate() and map() 3.1.1 nest() countries is a simplified version of dcldata::gm_countries, which contains Gapminder data on 197 countries. countries &lt;- gm_countries %&gt;% select(name, region_gm4, un_status, un_admission, income_wb_2017) countries #&gt; # A tibble: 197 × 5 #&gt; name region_gm4 un_status un_admission income_wb_2017 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; #&gt; 1 Afghanistan asia member 1946-11-19 Low income #&gt; 2 Albania europe member 1955-12-14 Upper middle income #&gt; 3 Algeria africa member 1962-10-08 Upper middle income #&gt; 4 Andorra europe member 1993-07-28 High income #&gt; 5 Angola africa member 1976-12-01 Lower middle income #&gt; 6 Antigua and Barbuda americas member 1981-11-11 High income #&gt; # … with 191 more rows The tidyr function nest() creates list columns of tibbles. Pass nest() the names of the columns to put into each individual tibble. nest() will create one row for each unique value of the remaining variables. For example, say we select just two columns from countries countries %&gt;% select(region_gm4, name) #&gt; # A tibble: 197 × 2 #&gt; region_gm4 name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 asia Afghanistan #&gt; 2 europe Albania #&gt; 3 africa Algeria #&gt; 4 europe Andorra #&gt; 5 africa Angola #&gt; 6 americas Antigua and Barbuda #&gt; # … with 191 more rows and then nest name. regions &lt;- countries %&gt;% select(region_gm4, name) %&gt;% nest(countries = name) regions #&gt; # A tibble: 4 × 2 #&gt; region_gm4 countries #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 asia &lt;tibble [59 × 1]&gt; #&gt; 2 europe &lt;tibble [49 × 1]&gt; #&gt; 3 africa &lt;tibble [54 × 1]&gt; #&gt; 4 americas &lt;tibble [35 × 1]&gt; nest() created one tibble for each region_gm4. Each of these tibbles contains all the countries that belong to the continent. regions$countries[[1]] #&gt; # A tibble: 59 × 1 #&gt; name #&gt; &lt;chr&gt; #&gt; 1 Afghanistan #&gt; 2 Australia #&gt; 3 Bahrain #&gt; 4 Bangladesh #&gt; 5 Bhutan #&gt; 6 Brunei #&gt; # … with 53 more rows The entire column is a list. typeof(regions$countries) #&gt; [1] &quot;list&quot; If we nest multiple variables, the individual tibbles will have multiple columns. regions_data &lt;- countries %&gt;% nest(data = c(name, un_status, un_admission, income_wb_2017)) regions_data #&gt; # A tibble: 4 × 2 #&gt; region_gm4 data #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 asia &lt;tibble [59 × 4]&gt; #&gt; 2 europe &lt;tibble [49 × 4]&gt; #&gt; 3 africa &lt;tibble [54 × 4]&gt; #&gt; 4 americas &lt;tibble [35 × 4]&gt; regions_data$data[[1]] #&gt; # A tibble: 59 × 4 #&gt; name un_status un_admission income_wb_2017 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; #&gt; 1 Afghanistan member 1946-11-19 Low income #&gt; 2 Australia member 1945-11-01 High income #&gt; 3 Bahrain member 1971-09-21 High income #&gt; 4 Bangladesh member 1974-09-17 Lower middle income #&gt; 5 Bhutan member 1971-09-21 Lower middle income #&gt; 6 Brunei member 1984-09-21 High income #&gt; # … with 53 more rows You can specify columns to nest using the same syntax as select(). countries %&gt;% nest(data = !region_gm4) #&gt; # A tibble: 4 × 2 #&gt; region_gm4 data #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 asia &lt;tibble [59 × 4]&gt; #&gt; 2 europe &lt;tibble [49 × 4]&gt; #&gt; 3 africa &lt;tibble [54 × 4]&gt; #&gt; 4 americas &lt;tibble [35 × 4]&gt; You can also create multiple list columns at once. countries %&gt;% nest(countries = name, data = c(name, contains(&quot;un&quot;), income_wb_2017)) #&gt; # A tibble: 4 × 3 #&gt; region_gm4 countries data #&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 asia &lt;tibble [59 × 1]&gt; &lt;tibble [59 × 4]&gt; #&gt; 2 europe &lt;tibble [49 × 1]&gt; &lt;tibble [49 × 4]&gt; #&gt; 3 africa &lt;tibble [54 × 1]&gt; &lt;tibble [54 × 4]&gt; #&gt; 4 americas &lt;tibble [35 × 1]&gt; &lt;tibble [35 × 4]&gt; 3.1.2 summarize() and list() You’ve used group_by() and summarize() to collapse groups into single rows. We can also use summarize() to create a list column, where each element is a vector, list, or tibble. If you supply list() with multiple atomic vectors, it will create a list of atomic vectors. list(c(1, 2, 3), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; [[1]] #&gt; [1] 1 2 3 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; We can use summarize() and list() to create a list of atomic vectors where each vector corresponds to one region_gm4. For example, the following creates a list column of countries. countries_collapsed &lt;- countries %&gt;% group_by(region_gm4) %&gt;% summarize(countries = list(name)) countries_collapsed #&gt; # A tibble: 4 × 2 #&gt; region_gm4 countries #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 africa &lt;chr [54]&gt; #&gt; 2 americas &lt;chr [35]&gt; #&gt; 3 asia &lt;chr [59]&gt; #&gt; 4 europe &lt;chr [49]&gt; The countries column is similar to the one created earlier with nest(), except each element is an atomic vector, not a tibble. typeof(countries_collapsed$countries[[1]]) #&gt; [1] &quot;character&quot; What if we want to manipulate each vector before creating the list column? For example, say we want to arrange all country names alphabetically. The following doesn’t work: countries %&gt;% group_by(region_gm4) %&gt;% summarize(countries = sort(name)) #&gt; # A tibble: 197 × 2 #&gt; # Groups: region_gm4 [4] #&gt; region_gm4 countries #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 africa Algeria #&gt; 2 africa Angola #&gt; 3 africa Benin #&gt; 4 africa Botswana #&gt; 5 africa Burkina Faso #&gt; 6 africa Burundi #&gt; # … with 191 more rows You need to collect all the atomic vectors into a list. countries %&gt;% group_by(region_gm4) %&gt;% summarize(countries = list(sort(name))) #&gt; # A tibble: 4 × 2 #&gt; region_gm4 countries #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 africa &lt;chr [54]&gt; #&gt; 2 americas &lt;chr [35]&gt; #&gt; 3 asia &lt;chr [59]&gt; #&gt; 4 europe &lt;chr [49]&gt; Here’s another example, which only stores in countries only the countries that begin with “A”. a_countries &lt;- countries %&gt;% group_by(region_gm4) %&gt;% summarize(countries = list(str_subset(name, &quot;^A&quot;))) a_countries #&gt; # A tibble: 4 × 2 #&gt; region_gm4 countries #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 africa &lt;chr [2]&gt; #&gt; 2 americas &lt;chr [2]&gt; #&gt; 3 asia &lt;chr [2]&gt; #&gt; 4 europe &lt;chr [5]&gt; a_countries$countries[[1]] #&gt; [1] &quot;Algeria&quot; &quot;Angola&quot; 3.1.3 mutate() The third way to create a list column is use to rowwise() and mutate(). For example, the following creates a list column where the element for each country is a vector of random numbers. countries %&gt;% select(name) %&gt;% rowwise() %&gt;% mutate(random = list(rnorm(n = str_length(name)))) %&gt;% ungroup() #&gt; # A tibble: 197 × 2 #&gt; name random #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 Afghanistan &lt;dbl [11]&gt; #&gt; 2 Albania &lt;dbl [7]&gt; #&gt; 3 Algeria &lt;dbl [7]&gt; #&gt; 4 Andorra &lt;dbl [7]&gt; #&gt; 5 Angola &lt;dbl [6]&gt; #&gt; 6 Antigua and Barbuda &lt;dbl [19]&gt; #&gt; # … with 191 more rows 3.2 Unnesting To transform a list column into normal columns, use unnest(). Here’s our tibble with a list column of country names. regions #&gt; # A tibble: 4 × 2 #&gt; region_gm4 countries #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 asia &lt;tibble [59 × 1]&gt; #&gt; 2 europe &lt;tibble [49 × 1]&gt; #&gt; 3 africa &lt;tibble [54 × 1]&gt; #&gt; 4 americas &lt;tibble [35 × 1]&gt; Supply the cols argument of unnest() with the name of the columns to unnest. regions %&gt;% unnest(cols = countries) #&gt; # A tibble: 197 × 2 #&gt; region_gm4 name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 asia Afghanistan #&gt; 2 asia Australia #&gt; 3 asia Bahrain #&gt; 4 asia Bangladesh #&gt; 5 asia Bhutan #&gt; 6 asia Brunei #&gt; # … with 191 more rows 3.3 Manipulating To manipulate list columns, you’ll often find it helpful to use row-wise operations. For example, say we want to find the number of countries in each continent. Here’s regions again. regions #&gt; # A tibble: 4 × 2 #&gt; region_gm4 countries #&gt; &lt;chr&gt; &lt;list&gt; #&gt; 1 asia &lt;tibble [59 × 1]&gt; #&gt; 2 europe &lt;tibble [49 × 1]&gt; #&gt; 3 africa &lt;tibble [54 × 1]&gt; #&gt; 4 americas &lt;tibble [35 × 1]&gt; We can’t call length() directly on countries, because we’ll just get the length of the entire column. regions %&gt;% mutate(num_countries = length(countries)) #&gt; # A tibble: 4 × 3 #&gt; region_gm4 countries num_countries #&gt; &lt;chr&gt; &lt;list&gt; &lt;int&gt; #&gt; 1 asia &lt;tibble [59 × 1]&gt; 4 #&gt; 2 europe &lt;tibble [49 × 1]&gt; 4 #&gt; 3 africa &lt;tibble [54 × 1]&gt; 4 #&gt; 4 americas &lt;tibble [35 × 1]&gt; 4 Instead, we need to iterate over each element or row of countries separately. regions %&gt;% rowwise() %&gt;% mutate(num_countries = nrow(countries)) %&gt;% ungroup() #&gt; # A tibble: 4 × 3 #&gt; region_gm4 countries num_countries #&gt; &lt;chr&gt; &lt;list&gt; &lt;int&gt; #&gt; 1 asia &lt;tibble [59 × 1]&gt; 59 #&gt; 2 europe &lt;tibble [49 × 1]&gt; 49 #&gt; 3 africa &lt;tibble [54 × 1]&gt; 54 #&gt; 4 americas &lt;tibble [35 × 1]&gt; 35 Note that we need to use nrow() because each element of countries is actually a tibble. This code finds the proportion of a region’s country names that end in “a”. regions %&gt;% rowwise() %&gt;% mutate( ends_in_a = sum(str_detect(countries$name, &quot;a$&quot;)) / nrow(countries) ) %&gt;% ungroup() %&gt;% arrange(desc(ends_in_a)) #&gt; # A tibble: 4 × 3 #&gt; region_gm4 countries ends_in_a #&gt; &lt;chr&gt; &lt;list&gt; &lt;dbl&gt; #&gt; 1 americas &lt;tibble [35 × 1]&gt; 0.457 #&gt; 2 africa &lt;tibble [54 × 1]&gt; 0.407 #&gt; 3 europe &lt;tibble [49 × 1]&gt; 0.347 #&gt; 4 asia &lt;tibble [59 × 1]&gt; 0.271 "],["functions.html", "4 Introduction", " 4 Introduction R is well-suited to a functional style of programming, which means you’ll often find yourself solving problems by applying various functions. For example, think about how you manipulate a tibble by applying a series of dplyr verbs until you arrive at the result you want. Because of this, it’s important to understand how functions work in R. The following chapters assume you already have experience writing functions in R, and immediately dive into some different types of functions: vector, scalar, predicate, and anonymous. "],["function-vector.html", "5 Vector functions 5.1 Temperature recommendations 5.2 Vector functions and mutate() 5.3 Vectorizing if-else statements", " 5 Vector functions library(tidyverse) Vector functions take a vector as input and produce a vector of the same length as output. Vector functions make working with vectors easy. For example, log10(), like most mathematical functions in R, is a vector function, which allows you to take the log of each element in a vector all at once. x &lt;- c(5, 2, 1) log10(x) #&gt; [1] 0.699 0.301 0.000 The simple mathematical operators are also vector functions: y &lt;- c(1, 2, 4) x + y #&gt; [1] 6 4 5 x * y #&gt; [1] 5 4 4 In contrast, functions that can only take a length one input and produce a length one output are called scalar functions. As you’ll see in the next section, the distinction between scalar and vector functions is important when working with tibbles. 5.1 Temperature recommendations A common way to create a scalar function is by using an if-else statement. For example, you might write the following function that tells you what to do based on the temperature outside: recommendation_1 &lt;- function(x) { if (x &gt;= 90) { &quot;locate air conditioning&quot; } else if (x &gt;= 60) { &quot;go outside&quot; } else if (x &gt;= 30) { &quot;wear a jacket&quot; } else if (x &gt;= 0) { &quot;wear multiple jackets&quot; } else { &quot;move&quot; } } This works well when applied to single values, recommendation_1(92) #&gt; [1] &quot;locate air conditioning&quot; recommendation_1(34) #&gt; [1] &quot;wear a jacket&quot; recommendation_1(-15) #&gt; [1] &quot;move&quot; but fails when applied to a vector with more than one element. temps &lt;- c(1, 55, 101) recommendation_1(temps) #&gt; Warning in if (x &gt;= 90) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; Warning in if (x &gt;= 60) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; Warning in if (x &gt;= 30) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; Warning in if (x &gt;= 0) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; [1] &quot;wear multiple jackets&quot; if can only handle a single value, but we gave recommendation_1() a vector. Instead of producing an error, if just processed the first element of that vector and gave us a warning. 5.2 Vector functions and mutate() Recall that a tibble is a list of vectors. Each column of the tibble is a vector, and all these vectors have to be the same length. New columns must also be vectors of the same length, which means that when you use mutate() to create a new column, mutate() has to create a new vector of the correct length. If you want, you can actually explicitly give mutate() a vector of the correct length. set.seed(128) df &lt;- tibble(temperature = sample(x = -15:110, size = 5, replace = TRUE)) df %&gt;% mutate(new_column = c(1, 2, 3, 4, 5)) #&gt; # A tibble: 5 × 2 #&gt; temperature new_column #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 -12 1 #&gt; 2 2 2 #&gt; 3 97 3 #&gt; 4 66 4 #&gt; 5 38 5 You can also give mutate() a single value, and it will repeat that value until it has a vector of the correct length. df %&gt;% mutate(one_value = 1) #&gt; # A tibble: 5 × 2 #&gt; temperature one_value #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 -12 1 #&gt; 2 2 1 #&gt; 3 97 1 #&gt; 4 66 1 #&gt; 5 38 1 However, if you try to give mutate() a vector with a length other than 1 or nrow(df), you’ll get an error: df %&gt;% mutate(two_values = c(1, 2)) #&gt; Error: Problem with `mutate()` column `two_values`. #&gt; ℹ `two_values = c(1, 2)`. #&gt; ℹ `two_values` must be size 5 or 1, not 2. mutate() doesn’t know how to turn a length 2 vector into a vector that has a value for each row in the tibble. As you already know, you usually create new columns by applying functions to existing ones. Say we want to convert our temperatures from Fahrenheit to Celsius. fahrenheit_to_celsius &lt;- function(degrees_fahrenheit) { (degrees_fahrenheit - 32) * (5 / 9) } df %&gt;% mutate(temperature_celsius = fahrenheit_to_celsius(temperature)) #&gt; # A tibble: 5 × 2 #&gt; temperature temperature_celsius #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 -12 -24.4 #&gt; 2 2 -16.7 #&gt; 3 97 36.1 #&gt; 4 66 18.9 #&gt; 5 38 3.33 When you reference a column inside mutate(), you reference the entire vector. So when we pass temperature to fahrenheit_to_celsius(), we pass the entire temperature vector. Mathematical operations are vectorized, so fahrenheit_to_celsius() takes the temperature vector and return a vector of the same length. mutate() then takes this new vector and successfully adds a column to the tibble. You can probably predict now what will happen if we try to use our scalar function, recommendation_1(), in the same way: df %&gt;% mutate(recommendation = recommendation_1(temperature)) #&gt; Warning in if (x &gt;= 90) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; Warning in if (x &gt;= 60) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; Warning in if (x &gt;= 30) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; Warning in if (x &gt;= 0) {: the condition has length &gt; 1 and only the first #&gt; element will be used #&gt; # A tibble: 5 × 2 #&gt; temperature recommendation #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 -12 move #&gt; 2 2 move #&gt; 3 97 move #&gt; 4 66 move #&gt; 5 38 move mutate() passes the entire temperature vector to recommendation_1(), which can’t handle a vector and so only processes the first element of temperature. However, because of how mutate() behaves when given a single value, the recommendation for the first temperature is copied for every single row. This isn’t very helpful, because now our tibble gives the same recommendation for every temperature. 5.3 Vectorizing if-else statements There are several ways to vectorize recommendation_1() so that it gives an accurate recommendation for each temperature in df. First, there’s a vectorized if-else function called if_else(): x &lt;- c(1, 3, 4) if_else(x == 4, true = &quot;four&quot;, false = &quot;not four&quot;) #&gt; [1] &quot;not four&quot; &quot;not four&quot; &quot;four&quot; However, in order to rewrite recommendation_1() using if_else(), we’d need to nest if_else() repeatedly and the function would become difficult to read. Another vector function, case_when(), is a better option. recommendation_2 &lt;- function(x) { case_when( x &gt;= 90 ~ &quot;locate air conditioning&quot;, x &gt;= 60 ~ &quot;go outside&quot;, x &gt;= 30 ~ &quot;wear a jacket&quot;, x &gt;= 0 ~ &quot;wear multiple jackets&quot;, TRUE ~ &quot;move&quot; ) } recommendation_2(temps) #&gt; [1] &quot;wear multiple jackets&quot; &quot;wear a jacket&quot; #&gt; [3] &quot;locate air conditioning&quot; df %&gt;% mutate(recommendation = recommendation_2(temperature)) #&gt; # A tibble: 5 × 2 #&gt; temperature recommendation #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 -12 move #&gt; 2 2 wear multiple jackets #&gt; 3 97 locate air conditioning #&gt; 4 66 go outside #&gt; 5 38 wear a jacket For other helpful vector functions, take a look at the Vector Functions section of the dplyr cheat sheet. "],["function-anonymous.html", "6 Anonymous functions", " 6 Anonymous functions library(tidyverse) Most functions you’ll encounter are named. Named functions are functions that are assigned to a variable. The variable allows you to call the function wherever you’d like without repeating the original code. excited_word() is a named function that turns a bored word into an excited one. The variable excited_word contains the function’s code, while excited_word() calls the function. excited_word &lt;- function(word) str_glue(&quot;{str_to_upper(word)}!!!&quot;) excited_word #&gt; function(word) str_glue(&quot;{str_to_upper(word)}!!!&quot;) excited_word(&quot;pinecones&quot;) #&gt; PINECONES!!! Anonymous functions are functions without names. They’re useful when you want to create a new function, but don’t plan on calling that function again. For example, you’ll commonly use anonymous function as arguments to other functions. In base R, the syntax for creating an anonymous function is very similar to the syntax for a named function. The only difference is that you don’t assign the function to a variable. The following is the anonymous function version of excited_word(). It contains only the function’s code. function(word) str_glue(&quot;{str_to_upper(word)}!!!&quot;) #&gt; function(word) str_glue(&quot;{str_to_upper(word)}!!!&quot;) You can call anonymous functions, although you have to wrap the entire function in parentheses. (function(word) str_glue(&quot;{str_to_upper(word)}!!!&quot;))(&quot;pinecones&quot;) #&gt; PINECONES!!! Fortunately, the tidyverse includes shortcuts for creating anonymous functions that make them much easier to read. You’ll learn about these shortcuts in the sections on purrr. "],["function-predicate.html", "7 Predicate functions", " 7 Predicate functions library(tidyverse) Predicate functions are functions that return a single TRUE or FALSE. You use predicate functions to check if your input meets some condition. For example, is.character() is a predicate function that returns TRUE if its input is of type character and FALSE otherwise. is.character(&quot;a&quot;) #&gt; [1] TRUE is.character(4.5) #&gt; [1] FALSE R does not have scalars. \"a\" is actually a character vector of length 1. is.character() and similar functions return a single value for all vectors, whether they have 1 element or many. x &lt;- c(&quot;a&quot;, &quot;b&quot;) is.character(x) #&gt; [1] TRUE In atomic vectors like x, all the elements must be the same type. The type of the individual elements will always be the same as the type of the atomic vector. You can use the function typeof() to find the type of a vector (or any other object in R). typeof(x) #&gt; [1] &quot;character&quot; is.character() simply checks whether x is of type character. If the vector is not a character vector, is.character() will return FALSE. y &lt;- c(1, 3) typeof(y) #&gt; [1] &quot;double&quot; is.character(y) #&gt; [1] FALSE Lists can have elements of any type. Even if all the elements of a list are of type character, the list is not a character vector, and is.character() will return FALSE. z &lt;- list(&quot;a&quot;, &quot;b&quot;) typeof(z) #&gt; [1] &quot;list&quot; is.character(z) #&gt; [1] FALSE "],["iteration.html", "8 Introduction", " 8 Introduction It’s often useful to apply the same function to every element of a vector, list, or tibble. The purrr package contains a set of useful functions for iterating over data structures and performing the same action at each element. In this section, we’ll introduce some of the most useful purrr functions and explain how to apply them in different situations. "],["purrr-basics.html", "9 Basic map functions 9.1 Iteration as an assembly line 9.2 The map functions", " 9 Basic map functions library(tidyverse) 9.1 Iteration as an assembly line You’ll often need to apply the same function to each element of a list or atomic vector. As an example, take moons, a list of vectors. moons &lt;- list( earth = 1737.1, mars = c(11.3, 6.2), neptune = c(60.4, 81.4, 156, 174.8, 194, 34.8, 420, 2705.2, 340, 62, 44, 42, 40, 60) ) (This data is from the Wikipedia pages on Earth’s Moon, Mars’s moons, and Neptune’s moons). Each vector in moons represents a planet. The elements of each vector represent the radii of that planet’s moons, in kilometers. (Note that some moons are irregularly shaped, so these are average radii.) Say we want to figure out the number of moons that belong to each planet by taking the length of each vector. We can’t just apply length() to moons. length(moons) #&gt; [1] 3 length(moons) returns the number of planets in moons. Instead, we need to apply length() to each vector in moons. We could find the length of each vector by individually pulling out each one and then applying length(). length(moons$earth) #&gt; [1] 1 length(moons$mars) #&gt; [1] 2 length(moons$neptune) #&gt; [1] 14 This strategy is tedious and repetitive, and would be even more tedious and repetitive if moons contained more planets. Fortunately, we can use functions from the purrr package to iterate through vectors and do the same thing to each element. In this reading, you’ll learn about the most basic purrr functions: the map functions. Take a look at the purrr cheatsheet for an overview of all the purrr functions. The map functions are like an assembly line in a factory. One conveyor belt, the input belt, transports various objects to a worker. The worker picks up each object and does something with it, but, importantly, never changes the object itself. For example, she might make a mold of the object, or grab a piece of plastic corresponding to the color of the object. Then, she places her new creation (the mold, piece of plastic, etc.) on the output belt. She does this until there are no new objects to process on the input belt and the conveyor belt stops. The factory then ends up with the same number of output objects as came in on the input belt. Imagine the map functions as this factory. You supply the map function with a list or vector (the objects on the input conveyor belt) and a function (what the worker does with each object). Then, the map function makes the conveyor belts run, applying the function to each element in the original vector to create a new vector of the same length, while never changing the original. In our moons example, the elements on the input belt are the vectors of moon radii. We want the worker to take the length of each vector by applying length(), producing three numbers on the output belt, each indicating a number of moons. In the next section, we’ll show you exactly how to carry out this operation with the map functions. 9.2 The map functions We’ll explain the most general map function, map(), first. map(), like all the map functions, takes a list/vector and a function as arguments. (All diagrams were adapted from https://adv-r.hadley.nz/functionals.html.) map() then applies that function to each element of the input list/vector. Applying the function to each element of the input list/vector results in one output element for each input element. map() then combines all these output elements into a list. In the assembly line metaphor, the input list/vector is the container for the items that go on the conveyor belt. The function specifies what the worker should do with each item. The items on the output conveyor belt make up the list that map() returns once it’s done. In our example, moons is our input. We want to apply length() to each element of moons, so length is the function. Each call to length() produces an integer, so the result is a list of integers. Here’s what the call to map() looks like: map(moons, length) #&gt; $earth #&gt; [1] 1 #&gt; #&gt; $mars #&gt; [1] 2 #&gt; #&gt; $neptune #&gt; [1] 14 Note that we used length, not length(), to specify which function to use. length() calls the function, while length refers to the function object. As we already said, map() returns a list. typeof(map(moons, length)) #&gt; [1] &quot;list&quot; A list of integers is fine, but you’ll often rather have an atomic vector of integers. purrr also contains variants of map() that produce atomic vectors. There is one variant for each type of atomic vector. map_int() creates an integer vector. map_dbl() creates a double vector. map_chr() creates a character vector. map_lgl() creates a logical vector. length() returns integers, so we’ll use map_int() to create an integer vector instead of a list. map_int(moons, length) #&gt; earth mars neptune #&gt; 1 2 14 The result looks similar to the result we got from map(), but is now an integer vector. typeof(map_int(moons, length)) #&gt; [1] &quot;integer&quot; map_int() requires that each output element be an integer. If each element is an integer, map_int() can then combine all the elements into a single atomic vector. The other variants of map() that produce double, character, and logical vectors work in the same way. We could use map() and median() to find the median moon radius for each planet. map(moons, median) #&gt; $earth #&gt; [1] 1737 #&gt; #&gt; $mars #&gt; [1] 8.75 #&gt; #&gt; $neptune #&gt; [1] 71.7 Or, we could use map_dbl() to produce a vector of doubles. map_dbl(moons, median) #&gt; earth mars neptune #&gt; 1737.10 8.75 71.70 Mars has very small moons! Use map_chr() to create a character vector when using a function that produces characters, and map_lgl() to create logical vectors. map_lgl(moons, is.double) #&gt; earth mars neptune #&gt; TRUE TRUE TRUE The map variants that produce atomic vectors will throw an error if your function doesn’t output the correct type. map_int(moons, median) #&gt; Error: Can&#39;t coerce element 1 from a double to a integer median() returns doubles, but map_int() expects integers, and cannot coerce doubles into integers. If you get a “Can’t coerce” error when working with map functions, you’re likely using the wrong variant. Some functions return vectors. For example, sort() returns a sorted version of a vector. sort(moons$neptune) #&gt; [1] 34.8 40.0 42.0 44.0 60.0 60.4 62.0 81.4 156.0 174.8 #&gt; [11] 194.0 340.0 420.0 2705.2 Even though sort() returns a vector of doubles, we can’t use map_dbl() to apply sort() to each element of moons. map_dbl(moons, sort) #&gt; Error: Result 2 must be a single double, not a double vector of length 2 map_dbl() requires that the function return a single double for each element of moons because atomic vectors can’t contain other vectors. sort() returns a vector of doubles for each element, so map_dbl() fails. Instead, we have to use map() to combine the individual output vectors into a list. map(moons, sort) #&gt; $earth #&gt; [1] 1737 #&gt; #&gt; $mars #&gt; [1] 6.2 11.3 #&gt; #&gt; $neptune #&gt; [1] 34.8 40.0 42.0 44.0 60.0 60.4 62.0 81.4 156.0 174.8 #&gt; [11] 194.0 340.0 420.0 2705.2 Because map() creates lists, it’s very flexible. We just used map() to create a list of vectors, but you can also use map() to create lists of lists, lists of lists of lists, lists of tibbles, lists of functions, etc. 9.2.1 Extra arguments In the previous section, we used sort() to arrange each vector. By default, sort() arranges in increasing order. map(moons, sort) #&gt; $earth #&gt; [1] 1737 #&gt; #&gt; $mars #&gt; [1] 6.2 11.3 #&gt; #&gt; $neptune #&gt; [1] 34.8 40.0 42.0 44.0 60.0 60.4 62.0 81.4 156.0 174.8 #&gt; [11] 194.0 340.0 420.0 2705.2 To sort in decreasing order, we have to specify decreasing = TRUE inside of sort(). Outside of a map function, we would just put decreasing = TRUE into the function call. sort(moons$neptune, decreasing = TRUE) #&gt; [1] 2705.2 420.0 340.0 194.0 174.8 156.0 81.4 62.0 60.4 60.0 #&gt; [11] 44.0 42.0 40.0 34.8 Inside a map function, you put function arguments directly after the function name. map(moons, sort, decreasing = TRUE) #&gt; $earth #&gt; [1] 1737 #&gt; #&gt; $mars #&gt; [1] 11.3 6.2 #&gt; #&gt; $neptune #&gt; [1] 2705.2 420.0 340.0 194.0 174.8 156.0 81.4 62.0 60.4 60.0 #&gt; [11] 44.0 42.0 40.0 34.8 You can add as many arguments as you like, and map() will automatically supply them to the function. For example, the following code uses two additional arguments to find the 95th quantile for each planet, excluding missing values. moons %&gt;% map_dbl(quantile, probs = 0.95, na.rm = TRUE) #&gt; earth mars neptune #&gt; 1737 11 1220 9.2.2 Anonymous functions So far in the reading, we’ve only given map named functions. Recall that named functions have a name which you can use to call the function. Say we want to convert the moon radii from kilometers to miles. Here’s a named function that turns kilometers into miles. km_to_miles &lt;- function(x) { x * 0.62 } Anytime we want to convert kilometers to miles, we can now call km_to_miles(). km_to_miles(22) #&gt; [1] 13.6 Now, we can use km_to_miles() and map() to convert all moon radii to miles. We have to use map() because km_to_miles() will return a vector for each planet. map(moons, km_to_miles) #&gt; $earth #&gt; [1] 1077 #&gt; #&gt; $mars #&gt; [1] 7.01 3.84 #&gt; #&gt; $neptune #&gt; [1] 37.4 50.5 96.7 108.4 120.3 21.6 260.4 1677.2 210.8 38.4 #&gt; [11] 27.3 26.0 24.8 37.2 If we’re not going to use km_to_miles() again, we don’t need to make a named function. It will be less work and more succinct to just create an anonymous function inside map(). Recall that anonymous functions are just functions without names, and the full syntax looks like this: function(x) x * 0.62 #&gt; function(x) x * 0.62 We can copy this anonymous function directly into map(). map(moons, function(x) x * 0.62) #&gt; $earth #&gt; [1] 1077 #&gt; #&gt; $mars #&gt; [1] 7.01 3.84 #&gt; #&gt; $neptune #&gt; [1] 37.4 50.5 96.7 108.4 120.3 21.6 260.4 1677.2 210.8 38.4 #&gt; [11] 27.3 26.0 24.8 37.2 The full syntax for anonymous functions is clunky, so purrr provides a shortcut. Here’s what the code looks like if we use the shortcut: moons %&gt;% map(~ . * 0.62) #&gt; $earth #&gt; [1] 1077 #&gt; #&gt; $mars #&gt; [1] 7.01 3.84 #&gt; #&gt; $neptune #&gt; [1] 37.4 50.5 96.7 108.4 120.3 21.6 260.4 1677.2 210.8 38.4 #&gt; [11] 27.3 26.0 24.8 37.2 The ~ tells map() that an anonymous function is coming. The . refers to the function argument, taking the place of x from the full anonymous function syntax. Just like when you supply map() with a named function, map() will apply an anonymous function to each element of moons. You can think of . as a placeholder, referring to earth, then mars, and then neptune as the conveyor belt delivers the vector of each planet’s moons to the worker. If a named function does not exist for your mapping, we recommend using an anonymous function instead of creating a named function, unless you’ll use the function again or the function is very long. We also recommend always using the syntax shortcut instead of the full anonymous function syntax. Anonymous functions can be confusing and tricky to get right. If you’re struggling to get the syntax correct, try testing your anonymous function on just a single element of your list. Here, we’ll explain one strategy for doing so. First, assign a single element of your list to the variable .. This looks strange, but means you’ll end up with a function that uses the purrr anonymous function syntax. . &lt;- moons[[3]] . #&gt; [1] 60.4 81.4 156.0 174.8 194.0 34.8 420.0 2705.2 340.0 62.0 #&gt; [11] 44.0 42.0 40.0 60.0 (We picked the third element because Neptune is more interesting than Earth, but it’s usually easiest to simply pick the first element with [[1]].) Then, figure out how to perform your desired operation on just that element. Check that the output is correct. . * 0.62 #&gt; [1] 37.4 50.5 96.7 108.4 120.3 21.6 260.4 1677.2 210.8 38.4 #&gt; [11] 27.3 26.0 24.8 37.2 Now, copy and paste your code into map(). Just remember to put a ~ at the beginning. moons %&gt;% map(~ . * 0.62) #&gt; $earth #&gt; [1] 1077 #&gt; #&gt; $mars #&gt; [1] 7.01 3.84 #&gt; #&gt; $neptune #&gt; [1] 37.4 50.5 96.7 108.4 120.3 21.6 260.4 1677.2 210.8 38.4 #&gt; [11] 27.3 26.0 24.8 37.2 Let’s walk through a more complicated example. Say you want to find the number of large moons that belong to each planet. We’ll define a large moon as a moon with a radius greater than 100 kilometers. First, assign an element of your list to .. . &lt;- moons[[3]] . #&gt; [1] 60.4 81.4 156.0 174.8 194.0 34.8 420.0 2705.2 340.0 62.0 #&gt; [11] 44.0 42.0 40.0 60.0 Then, build and test your function just for .. First, we need to subset . so that it just includes moon radii greater than 100. Recall the syntax for subsetting vectors. x[x == 1] extracts just the elements of some vector x that are equal to 1. x[x &gt; 2] gives you all the elements of x greater than 2. Use this syntax to extract the moon radii in . that are greater than 100. .[. &gt; 100] #&gt; [1] 156 175 194 420 2705 340 Then, take the length of this new vector to find the number of moons it contains. length(.[. &gt; 100]) #&gt; [1] 6 Now, copy and paste your code into a map function after a ~. We’ll use map_int() because length() returns integers. moons %&gt;% map_int(~ length(.[. &gt; 100])) #&gt; earth mars neptune #&gt; 1 0 6 This strategy makes the purrr anonymous function syntax less abstract and allows you to test your anonymous functions before plugging them into a map function. 9.2.3 Tibbles All the examples so far have used the map function on moons, a list of vectors, but the map functions work on any type of vector or list, including tibbles. Tibbles are lists of vectors. Notice that when you create a tibble with tibble(), you create a vector for each column. y &lt;- tibble( col_1 = c(1, 2, 3), col_2 = c(100, 200, 300), col_3 = c(0.1, 0.2, 0.3) ) Because the elements of a tibble are the vector columns, map functions act on the tibble columns, not the tibble rows. map_dbl(y, median) #&gt; col_1 col_2 col_3 #&gt; 2.0 200.0 0.2 Here’s another example that finds the number of NA’s in each column of nycflights13::flights. nycflights13::flights %&gt;% map_int(~ sum(is.na(.))) #&gt; year month day dep_time sched_dep_time #&gt; 0 0 0 8255 0 #&gt; dep_delay arr_time sched_arr_time arr_delay carrier #&gt; 8255 8713 0 9430 0 #&gt; flight tailnum origin dest air_time #&gt; 0 2512 0 0 9430 #&gt; distance hour minute time_hour #&gt; 0 0 0 0 "],["purrr-parallel.html", "10 Map with multiple inputs 10.1 map2() 10.2 pmap()", " 10 Map with multiple inputs library(tidyverse) In the previous purrr units, you learned how to use the map() functions to iterate over a single vector and apply a function to each element. purrr also contains functions that can iterate over several vectors in parallel, supplying the first elements of each vector to a given function, then the second, then the third, etc. purrr’s parallel mapping functions allow the assembly line to have multiple, synchronized input conveyor belts. Our factory worker uses the nth item from each input conveyor belt to create a new object that becomes the nth item on the output conveyor belt. Below, you’ll learn about the map2() functions, which can handle two input vectors, and the pmap() functions, which can handle any number of input vectors. 10.1 map2() The map2() functions are very similar to the map() functions you learned about previously, but they take two input vectors instead of one. For example, here are two vectors, x and y. x &lt;- c(1, 2, 4) y &lt;- c(6, 5, 3) We can use a map2() variant to iterate along both vectors in parallel. The following code creates a new vector whose first element is the minimum of x[1] and y[1], second element is the minimum of x[2] and y[2], and third element is the minimum of x[3] and y[3]. map2_dbl(x, y, min) #&gt; [1] 1 2 3 Since the map2() functions iterate along the two vectors in parallel, they need to be the same length. x2 &lt;- c(1, 2, 4) y2 &lt;- c(6, 5) map2_dbl(x2, y2, min) #&gt; Error: Mapped vectors must have consistent lengths: #&gt; * `.x` has length 3 #&gt; * `.y` has length 2 Inside anonymous functions in the map() functions, you refer to each element of the input vector as . . In the map2() functions, you refer to elements of the first vector as .x and elements of the second as .y . map2_chr(x, y, ~ str_glue(&quot;The minimum of {.x} and {.y} is {min(.x, .y)}.&quot;)) #&gt; [1] &quot;The minimum of 1 and 6 is 1.&quot; &quot;The minimum of 2 and 5 is 2.&quot; #&gt; [3] &quot;The minimum of 4 and 3 is 3.&quot; If you don’t create an anonymous function and use a named function instead, the first vector will be supplied as the first argument to the function and the second vector will be supplied as the second argument. Remember that tibble columns are vectors, so you can use map2() inside mutate() to alter tibble columns. df &lt;- tibble( a = c(1, 2, 4), b = c(6, 5, 3) ) df %&gt;% mutate(min = map2_dbl(a, b, min)) #&gt; # A tibble: 3 × 3 #&gt; a b min #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 6 1 #&gt; 2 2 5 2 #&gt; 3 4 3 3 By default, mutate() uses column-wise operations. map2_dbl() produces a column the same length at a and b. We can accomplish the same calculation using row-wise operations. df %&gt;% rowwise() %&gt;% mutate(min = min(a, b)) %&gt;% ungroup() #&gt; # A tibble: 3 × 3 #&gt; a b min #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 6 1 #&gt; 2 2 5 2 #&gt; 3 4 3 3 10.2 pmap() There are no map3() or map4() functions. Instead, you can use a pmap() (p for parallel) function to map over more than two vectors. The pmap() functions work slightly differently than the map() and map2() functions. In map() and map2() functions, you specify the vector(s) to supply to the function. In pmap() functions, you specify a single list that contains all the vectors (or lists) that you want to supply to your function. Flipping the list diagram makes it easier to see that pmap() is basically just a generalized version of map2(). The only difference is that map2() lets you specify each vector as a separate argument. In pmap(), you have to store all your input vectors in a single list. This functionality allows pmap() to handle any number of input vectors. Here’s our earlier map2() statement. map2_dbl(x, y, min) #&gt; [1] 1 2 3 To do this in pmap(), just create a list out of x and y. pmap_dbl(list(x, y), min) #&gt; [1] 1 2 3 If you only have two input vectors, though, use map2(). If we want to apply min() to parallel elements of three vectors, we’ll need to use pmap(). z is a third vector. z &lt;- c(100, 15, 1) Again, we need to combine all the individual vectors into a single list in order to use pmap(). pmap_dbl(list(x, y, z), min) #&gt; [1] 1 2 1 Tibbles are lists, so we could also combine x, y, and z into a tibble. tibble( a = c(50, 60, 70), b = c(10, 90, 40), c = c(1, 105, 2000) ) %&gt;% pmap_dbl(min) #&gt; [1] 1 60 40 10.2.1 Anonymous functions pmap() can involve any number of input vectors, so we need a new way of referring to each vector in an anonymous function. Instead of using ., .x, or .y, use ..1., ..2, ..3, etc. to refer to the different vectors. state_animals is a tibble with some information on the official animals of different states. state_animals &lt;- tribble( ~state, ~type, ~animal, ~binomial, &quot;Alaska&quot;, &quot;land mammal&quot;, &quot;Moose&quot;, &quot;Alces alces&quot;, &quot;Delaware&quot;, &quot;bug&quot;, &quot;7-spotted ladybug&quot;, &quot;Coccinella septempunctata&quot;, &quot;Hawaii&quot;, &quot;fish&quot;, &quot;Humuhumunukunukuāpuaʻa&quot;, &quot;Rhinecanthus rectangulus&quot;, &quot;Maine&quot;, &quot;crustacean&quot;, &quot;lobster&quot;, &quot;Homarus americanus&quot; ) state_animals #&gt; # A tibble: 4 × 4 #&gt; state type animal binomial #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Alaska land mammal Moose Alces alces #&gt; 2 Delaware bug 7-spotted ladybug Coccinella septempunctata #&gt; 3 Hawaii fish Humuhumunukunukuāpuaʻa Rhinecanthus rectangulus #&gt; 4 Maine crustacean lobster Homarus americanus We can use pmap() to write short descriptions for each state. state_animals %&gt;% pmap_chr(~ str_glue(&quot;The {..1} state {..2} is the {..3}.&quot;)) #&gt; [1] &quot;The Alaska state land mammal is the Moose.&quot; #&gt; [2] &quot;The Delaware state bug is the 7-spotted ladybug.&quot; #&gt; [3] &quot;The Hawaii state fish is the Humuhumunukunukuāpuaʻa.&quot; #&gt; [4] &quot;The Maine state crustacean is the lobster.&quot; ..1 refers to the first variable (state), ..2 to the second (type), and ..3 to the third (animal). 10.2.2 Named functions If you supply pmap() a named function, it will match the names of the input list with the names of the function arguments. This can result in elegant code. But for this to work, it’s important that: The list or tibble input variable names match those of the function arguments. You have the same number of input variables as function arguments. Let’s start with an example of what doesn’t work. First, we’ll create a named function. state_sentence &lt;- function(animal, type, state) { str_glue(&quot;The {state} state {type} is the {animal}.&quot;) } This does not work: state_animals %&gt;% pmap_chr(state_sentence) #&gt; Error in .f(state = .l[[1L]][[i]], type = .l[[2L]][[i]], animal = .l[[3L]][[i]], : unused argument (binomial = .l[[4]][[i]]) state_animals has four variables, but state_sentence is expecting three. The number of input variables must match the number of function arguments. The easiest way to fix the problem is to just get rid of the unused variable. state_animals %&gt;% select(!binomial) %&gt;% pmap_chr(state_sentence) #&gt; [1] &quot;The Alaska state land mammal is the Moose.&quot; #&gt; [2] &quot;The Delaware state bug is the 7-spotted ladybug.&quot; #&gt; [3] &quot;The Hawaii state fish is the Humuhumunukunukuāpuaʻa.&quot; #&gt; [4] &quot;The Maine state crustacean is the lobster.&quot; Note that the order of the variables in state_animals is different than the order of the arguments in state_sentence. pmap() matches input variables with function arguments by name, so the orderings don’t matter. However, this means that the two sets of names must be identical. "],["purrr-extras.html", "11 Other purrr functions 11.1 Map functions that output tibbles 11.2 Walk 11.3 Predicate functions", " 11 Other purrr functions library(tidyverse) In this reading, you’ll learn about two more map variants, map_dfr() and map_dfc(). Then, you’ll learn about walk(), as well as some useful purrr functions that work with functions that return either TRUE or FALSE. The purrr package contains more functions than we can cover. The purrr cheatsheet is a great way to find helpful functions when you encounter a new type of iteration problem. 11.1 Map functions that output tibbles Instead of creating an atomic vector or list, the map variants map_dfr() and map_dfc() create a tibble. With these map functions, the assembly line worker creates a tibble for each input element, and the output conveyor belt ends up with a collection of tibbles. The worker then combines all the small tibbles into a single, larger tibble. There are multiple ways to combine smaller tibbles into a larger tibble. map_dfr() (r for rows) stacks the smaller tibbles on top of each other. map_dfc() (c for columns) stacks them side-by-side. There are _dfr and _dfc variants of pmap() and map2() as well. In the following sections, we’ll cover map_dfr() and map_dfc() in more detail. 11.1.1 _dfr map_dfr() is useful when reading in data from multiple files. The following code reads in several very simple csv files, each of which contains the name of a different dinosaur genus. read_csv(&quot;data/purrr-extras/file_001.csv&quot;) #&gt; # A tibble: 1 × 2 #&gt; id genus #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 Hoplitosaurus read_csv(&quot;data/purrr-extras/file_002.csv&quot;) #&gt; # A tibble: 1 × 2 #&gt; id genus #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2 Herrerasaurus read_csv(&quot;data/purrr-extras/file_003.csv&quot;) #&gt; # A tibble: 1 × 2 #&gt; id genus #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 3 Coelophysis read_csv() produces a tibble, and so we can use map_dfr() to map over all three file names and bind the resulting individual tibbles into a single tibble. files &lt;- str_glue(&quot;data/purrr-extras/file_00{1:3}.csv&quot;) files #&gt; data/purrr-extras/file_001.csv #&gt; data/purrr-extras/file_002.csv #&gt; data/purrr-extras/file_003.csv files %&gt;% map_dfr(read_csv) #&gt; # A tibble: 3 × 2 #&gt; id genus #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 Hoplitosaurus #&gt; 2 2 Herrerasaurus #&gt; 3 3 Coelophysis The result is a tibble with three rows and two columns, because map_dfr() aligns the columns of the individual tibbles by name. The individual tibbles can have different numbers of rows or columns. map_dfr() just creates a column for each unique column name. If some of the individual tibbles lack a column that others have, map_dfr() fills in with NA values. read_csv(&quot;data/purrr-extras/file_004.csv&quot;) #&gt; # A tibble: 2 × 3 #&gt; id genus start_period #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 4 Dilophosaurus Sinemurian #&gt; 2 5 Segisaurus Pliensbachian c(files, &quot;data/purrr-extras/file_004.csv&quot;) %&gt;% map_dfr(read_csv) #&gt; # A tibble: 5 × 3 #&gt; id genus start_period #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Hoplitosaurus &lt;NA&gt; #&gt; 2 2 Herrerasaurus &lt;NA&gt; #&gt; 3 3 Coelophysis &lt;NA&gt; #&gt; 4 4 Dilophosaurus Sinemurian #&gt; 5 5 Segisaurus Pliensbachian 11.1.2 _dfc map_dfc() is typically less useful than map_dfr() because it relies on row position to stack the tibbles side-by-side. Row position is prone to error, and it will often be difficult to check if the data in each row is aligned correctly. However, if you have data with variables in different places and are positive the rows are aligned, map_dfc() may be appropriate. Unfortunately, even if the individual tibbles contain a unique identifier for each row, map_dfc() doesn’t use the identifiers to verify that the rows are aligned correctly, nor does it combine identically named columns. read_csv(&quot;data/purrr-extras/file_005.csv&quot;) #&gt; # A tibble: 1 × 3 #&gt; id diet start_period #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 herbivore Barremian c(&quot;data/purrr-extras/file_001.csv&quot;, &quot;data/purrr-extras/file_005.csv&quot;) %&gt;% map_dfc(read_csv) #&gt; # A tibble: 1 × 5 #&gt; id...1 genus id...3 diet start_period #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Hoplitosaurus 1 herbivore Barremian Instead, you end up with a duplicated column (id...1 and id...3). If you have a unique identifier for each row, it is much better to join on that identifier. left_join( read_csv(&quot;data/purrr-extras/file_001.csv&quot;), read_csv(&quot;data/purrr-extras/file_005.csv&quot;), by = &quot;id&quot; ) #&gt; # A tibble: 1 × 4 #&gt; id genus diet start_period #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Hoplitosaurus herbivore Barremian Also, because map_dfc() combines tibbles by row position, the tibbles can have different numbers of columns, but they should have the same number of rows. 11.2 Walk The walk functions work similarly to the map functions, but you use them when you’re interested in applying a function that performs an action instead of producing data (e.g., print()). The walk functions are useful for performing actions like writing files and printing plots. For example, say we used purrr to generate a list of plots. set.seed(745) plot_rnorm &lt;- function(sd) { tibble(x = rnorm(n = 5000, mean = 0, sd = sd)) %&gt;% ggplot(aes(x)) + geom_histogram(bins = 40) + geom_vline(xintercept = 0, color = &quot;blue&quot;) } plots &lt;- c(5, 1, 9) %&gt;% map(plot_rnorm) We can now use walk() to print them out. plots %&gt;% walk(print) The walk functions look like they don’t return anything, but they actually return their input invisibly. When functions return something invisibly, it just means they don’t print their return value out when you call them. This functionality makes the walk functions useful in pipes. You can call a walk function to perform an action, get your input back, and continue operating on that input. 11.3 Predicate functions In Chapter 7, we introduced predicate functions, which are functions that return a single TRUE or FALSE. purrr includes several useful functions that work with predicate functions. keep() and discard() iterate over a vector and keep or discard only those elements for which the predicate function returns TRUE. x &lt;- list( a = c(1, 2), b = c(4, 5, 6), c = c(&quot;a&quot;, &quot;z&quot;) ) x %&gt;% discard(is.character) #&gt; $a #&gt; [1] 1 2 #&gt; #&gt; $b #&gt; [1] 4 5 6 x %&gt;% keep(~ length(.) == 2) #&gt; $a #&gt; [1] 1 2 #&gt; #&gt; $c #&gt; [1] &quot;a&quot; &quot;z&quot; With tibbles, you can use keep() and discard() to select columns that meet a certain condition. mpg %&gt;% keep(is.numeric) #&gt; # A tibble: 234 × 5 #&gt; displ year cyl cty hwy #&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1.8 1999 4 18 29 #&gt; 2 1.8 1999 4 21 29 #&gt; 3 2 2008 4 20 31 #&gt; 4 2 2008 4 21 30 #&gt; 5 2.8 1999 6 16 26 #&gt; 6 2.8 1999 6 18 26 #&gt; # … with 228 more rows some() looks at the entire input vector and returns TRUE if the predicate is true for any element of the vector and FAlSE otherwise. mpg %&gt;% some(is.numeric) #&gt; [1] TRUE For every() to return TRUE, every element of the vector must meet the predicate. mpg %&gt;% every(is.numeric) #&gt; [1] FALSE Other useful purrr functions that use predicate functions include head_while(), compact(), has_element(), and detect(). Take a look at the purrr cheatsheet for details. "],["tidy-eval-section.html", "12 Introduction", " 12 Introduction library(tidyverse) At some point, you might have found yourself copy-and-pasting the same dplyr code over and over again. For example, the following code uses group_by() and summarize() to calculate different grouped means of mpg. mpg %&gt;% group_by(manufacturer) %&gt;% summarize(mean = mean(cty)) mpg %&gt;% group_by(drv) %&gt;% summarize(mean = mean(cty)) mpg %&gt;% group_by(model) %&gt;% summarize(mean = mean(hwy)) A function would cut down on duplicated code. Here’s a first pass: grouped_mean &lt;- function(var_group, var_summary) { mpg %&gt;% group_by(var_group) %&gt;% summarize(mean = mean(var_summary)) } Unfortunately, it doesn’t work. grouped_mean(var_group = manufacturer, var_summary = cty) #&gt; Error: Must group by variables found in `.data`. #&gt; * Column `var_group` is not found. dplyr verbs and other tidyverse functions that operate on data frames work differently than many other R functions. In this section, you’ll learn what makes these functions different and figure out how to make functions like grouped_mean() work. The underlying idea that makes this all possible is called tidy evaluation. Tidy evaluation is a complicated subject. Luckily, you don’t need to understand all the theory or the under-the-hood mechanics to use tidy evaluation. The Basics chapter is a high-level, practical overview of the basic tidy evaluation use-cases. The goal of the chapter is to show you what to do without going into much theory. If you’re curious tidy evaluation and want to learn more, the following are useful resources. Note that the {{ }} operator, which you’ll learn about in the next chapter, was not implemented when some of these were written. Instead of {{ }}, you’ll usually see !! and enquo(). Programming with dplyr vignette Tidy evaluation with rlang cheat sheet And if you really want to go back to the beginning: Quasi-quotation "],["tidy-eval-basics.html", "13 Tidy evaluation basics 13.1 Embracing with {{ }} 13.2 Forwarding with ... 13.3 Assigning names 13.4 Splicing with !!!", " 13 Tidy evaluation basics Likely without realizing it, you’ve been using two types of variables in R. First, there are what we’ll call environment variables. When you create an environment variable, you bind a value to a name in the current environment. For example, the following code creates an environment variable named y that refers to 1. y &lt;- 1 Now, when we call y, we get whatever value y refers to. y #&gt; [1] 1 The second type of variable we’ll call data variables. Data variables refer to columns in data frames, and only make sense in the context of those data frames. For example, manufacturer is a data variable that exists in the context of mpg. dplyr, ggplot2, and other tidyverse packages understand this, which is why functions like select() behave as you want. mpg %&gt;% select(manufacturer) #&gt; # A tibble: 234 × 1 #&gt; manufacturer #&gt; &lt;chr&gt; #&gt; 1 audi #&gt; 2 audi #&gt; 3 audi #&gt; 4 audi #&gt; 5 audi #&gt; 6 audi #&gt; # … with 228 more rows Instead of figuring out what manufacturer refers to in the environment, select() looks for a column named “manufacturer” in mpg. Let’s take a look at our failed function from the intro again. grouped_mean &lt;- function(var_group, var_summary) { mpg %&gt;% group_by(var_group) %&gt;% summarize(mean = mean(var_summary)) } grouped_mean(var_group = manufacturer, var_summary = cty) #&gt; Error: Must group by variables found in `.data`. #&gt; * Column `var_group` is not found. group_by() thinks that var_group is a data variable, and so it looks inside mpg for a column called “var_group”, doesn’t find it, and so throws an error. We actually want var_group to behave as a hybrid between an environment variable and a data variable. Like an environment variable, we want it to refer to another value (manufacturer). Then, we want group_by() to treat that value (manufacturer) as a data variable and look inside mpg for the matching column. 13.1 Embracing with {{ }} To fix grouped_mean(), all we need to do is embrace var_group and var_summary with {{ }} (pronounced “curly curly”). grouped_mean &lt;- function(var_group, var_summary) { mpg %&gt;% group_by({{ var_group }}) %&gt;% summarize(mean = mean({{ var_summary }})) } grouped_mean(var_group = manufacturer, var_summary = cty) #&gt; # A tibble: 15 × 2 #&gt; manufacturer mean #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 audi 17.6 #&gt; 2 chevrolet 15 #&gt; 3 dodge 13.1 #&gt; 4 ford 14 #&gt; 5 honda 24.4 #&gt; 6 hyundai 18.6 #&gt; # … with 9 more rows {{ }} might remind you of the use of { } in glue(), and they fill similar roles. Let’s look at another example. This doesn’t work: plot_mpg &lt;- function(var) { mpg %&gt;% ggplot(aes(var)) + geom_bar() } plot_mpg(drv) #&gt; Error in FUN(X[[i]], ...): object &#39;drv&#39; not found We want var to behave as a hybrid environment-data variable, so we need {{ }}. plot_mpg &lt;- function(var) { mpg %&gt;% ggplot(aes({{ var }})) + geom_bar() } plot_mpg(drv) 13.2 Forwarding with ... You might have noticed that some functions, like the purrr functions, take ... as a final argument, allowing you to specify any number of additional arguments. You can use ... in your own functions. There are two common use-cases. 13.2.1 Passing full expressions Functions like filter() take expressions, like year == 1999 or manufacturer == \"audi\". If you want to build a function that takes full expressions, you can use .... mpg_filter &lt;- function(...) { mpg %&gt;% filter(...) } mpg_filter(manufacturer == &quot;audi&quot;, year == 1999) #&gt; # A tibble: 9 × 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… #&gt; 2 audi a4 1.8 1999 4 manua… f 21 29 p comp… #&gt; 3 audi a4 2.8 1999 6 auto(… f 16 26 p comp… #&gt; 4 audi a4 2.8 1999 6 manua… f 18 26 p comp… #&gt; 5 audi a4 quattro 1.8 1999 4 manua… 4 18 26 p comp… #&gt; 6 audi a4 quattro 1.8 1999 4 auto(… 4 16 25 p comp… #&gt; # … with 3 more rows ... can take any number of arguments, so we can filter by an unlimited number of conditions. mpg_filter( manufacturer == &quot;audi&quot;, year == 1999, drv == &quot;f&quot;, fl == &quot;p&quot; ) #&gt; # A tibble: 4 × 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… #&gt; 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… #&gt; 3 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… #&gt; 4 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… mpg_filter() forwards ... to filter(), which allows filter() to act on the contents of ... just as it would outside of the function. Here’s another example that uses select(). mpg_select &lt;- function(...) { mpg %&gt;% select(...) } mpg_select(car = model, drivetrain = drv) #&gt; # A tibble: 234 × 2 #&gt; car drivetrain #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 a4 f #&gt; 2 a4 f #&gt; 3 a4 f #&gt; 4 a4 f #&gt; 5 a4 f #&gt; 6 a4 f #&gt; # … with 228 more rows 13.2.2 Additional arguments Sometimes, you’ll want your function to take named arguments, but you’ll also want to allow for any number of additional arguments. You can use {{ }}, and .... grouped_mean_2 &lt;- function(df, var_summary, ...) { df %&gt;% group_by(...) %&gt;% summarize(mean = mean({{ var_summary }})) %&gt;% ungroup() } grouped_mean_2(df = mpg, var_summary = cty, year, drv) #&gt; # A tibble: 6 × 3 #&gt; year drv mean #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1999 4 14.2 #&gt; 2 1999 f 20.0 #&gt; 3 1999 r 14 #&gt; 4 2008 4 14.4 #&gt; 5 2008 f 20.0 #&gt; 6 2008 r 14.1 With the ..., we can pass any number of grouping variables into group_by(). grouped_mean_2(df = mpg, var_summary = cty, year, drv, class) #&gt; # A tibble: 23 × 4 #&gt; year drv class mean #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1999 4 compact 16.5 #&gt; 2 1999 4 midsize 15 #&gt; 3 1999 4 pickup 13 #&gt; 4 1999 4 subcompact 19.5 #&gt; 5 1999 4 suv 13.8 #&gt; 6 1999 f compact 20.4 #&gt; # … with 17 more rows 13.3 Assigning names When you want to pass the name of a column into your function, you need to: Embrace the name with {{ }}. Use := instead of = to assign the name. summary_mean &lt;- function(df, var_summary, name_summary){ df %&gt;% summarize({{ name_summary }} := mean({{ var_summary }})) } summary_mean(df = mpg, var_summary = cty, name_summary = cty_mean) #&gt; # A tibble: 1 × 1 #&gt; cty_mean #&gt; &lt;dbl&gt; #&gt; 1 16.9 You have to use := instead of just plain = because you can’t use {{ }} on both sides of a =. (:= is called the walrus operator because it looks like a sideways walrus.) 13.4 Splicing with !!! Say you want to recode a variable: mpg %&gt;% mutate(drv = recode(drv, &quot;f&quot; = &quot;front&quot;, &quot;r&quot; = &quot;rear&quot;, &quot;4&quot; = &quot;four&quot;)) #&gt; # A tibble: 234 × 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto(l5) front 18 29 p compa… #&gt; 2 audi a4 1.8 1999 4 manual(m5) front 21 29 p compa… #&gt; 3 audi a4 2 2008 4 manual(m6) front 20 31 p compa… #&gt; 4 audi a4 2 2008 4 auto(av) front 21 30 p compa… #&gt; 5 audi a4 2.8 1999 6 auto(l5) front 16 26 p compa… #&gt; 6 audi a4 2.8 1999 6 manual(m5) front 18 26 p compa… #&gt; # … with 228 more rows It’s often a good idea to store your recode mapping as a vector in your parameters section. To get this to work, you’ll need another tidyeval operator, !!!. recode_drv &lt;- c(f = &quot;front&quot;, r = &quot;rear&quot;, &quot;4&quot; = &quot;four&quot;) mpg %&gt;% mutate(drv = recode(drv, !!! recode_drv)) #&gt; # A tibble: 234 × 11 #&gt; manufacturer model displ year cyl trans drv cty hwy fl class #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 audi a4 1.8 1999 4 auto(l5) front 18 29 p compa… #&gt; 2 audi a4 1.8 1999 4 manual(m5) front 21 29 p compa… #&gt; 3 audi a4 2 2008 4 manual(m6) front 20 31 p compa… #&gt; 4 audi a4 2 2008 4 auto(av) front 21 30 p compa… #&gt; 5 audi a4 2.8 1999 6 auto(l5) front 16 26 p compa… #&gt; 6 audi a4 2.8 1999 6 manual(m5) front 18 26 p compa… #&gt; # … with 228 more rows !!! has two tasks: Unpack recode_drv so that each element is passed as a separate argument to recode() (i.e., \"f\" = \"front\", \"r\" = \"rear\", \"4\" = \"four\" instead of c(\"f\" = \"front\", \"r\" = \"rear\", \"4\" = \"four\")). Make sure that recode() treats the individual elements as data variables. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
